import sympy as sp
from sympy.matrices.normalforms import smith_normal_form

class quotient_lattice_class:
    # A class to represent the equivalence class in a quotient lattice
    # That is, an element of Z^n / L, where L is generated by the columsn of lattice_matrix
    
    def __init__(self, representative, lattice_matrix):
        
        rows, cols = lattice_matrix.shape
        assert(len(representative) == rows)
        
        self.representative = representative
        self.lattice_matrix = lattice_matrix
        self.ambient_dimension = rows
        
        # construct lattice_matrix (columns are generators)
        # then compute the smith normal form,
        # and the signature (the nonzero diagonal entries of the smith normal form)
        self.snf = smith_normal_form(self.lattice_matrix)
        self.lattice_signature = (tuple(int(self.snf[i,i])
                                        for i in range(min(self.snf.rows, self.snf.cols)) 
                                        if self.snf[i,i] != 0))

    @staticmethod
    def in_integer_column_span(v, M):
        # return true if v is in the column span of the matrix M
        # Solve M * x = v over integers
        x = sp.symbols(f'x:{M.shape[1]}', integer=True)
        sol = sp.linsolve((M, v), x)
        return bool(sol) # linsolve returns empty set if no solution exists

    def display(self, show_matrices = True):
        print("Quotient lattice object with")
        print("Vector representative:",self.representative)
        
        if show_matrices:
            print("Matrix of lattice generators:")
            sp.pprint(self.lattice_matrix)
            print("Smith normal form of lattice matrix:")
            sp.pprint(self.snf)
            
        print("Lattice signature:",self.lattice_signature)
            
    def __add__(self, other):
        self._check_compatible(other)
        return quotient_lattice_class(self.representative + other.representative,self.lattice_matrix)

    def __sub__(self, other):
        self._check_compatible(other)
        return quotient_lattice_class(self.representative - other.representative,self.lattice_matrix)

    def __mul__(self, n):
        return quotient_lattice_class(n * self.representative, self.lattice_matrix)

    def __eq__(self, other):
        if not isinstance(other, quotient_lattice_class): return False
        self._check_compatible(other)
        difference = self.representative - other.representative
        return self.in_integer_column_span(difference, self.lattice_matrix)

    def _check_compatible(self, other):
        if self.ambient_dimension != other.ambient_dimension:
            raise ValueError("Character classes from different ambient spaces")
        if self.lattice_signature != other.lattice_signature:
            raise ValueError("Character classes over different lattices")
