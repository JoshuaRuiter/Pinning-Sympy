# Various general utility functions related to matrices

import sympy as sp
import numpy as np
import itertools
import time

def in_integer_column_span(v, M):
    # return true if v is in the column span of the matrix M
    # Just add v as a column to the end of M and see if the rank increased
    # If the rank increases after augmenting with v, then v isn't in the span
    mat_M = sp.Matrix(M)
    mat_v = sp.Matrix(v)
    rows, cols = mat_v.shape
    assert((rows==1) or (cols==1))
    if rows == 1: mat_v = mat_v.transpose() # If v is a row vector, transpose it
    return mat_M.rank() == mat_M.row_join(mat_v).rank()

def ints_near_zero(bound):
    yield 0
    for i in range(1,bound+1):
        yield i
        yield -i

def is_diagonal(my_matrix):
    # Return true if matrix is diagonal'    
    rows, cols = my_matrix.shape
    return all(my_matrix[i,j] == 0 for i in range(rows) for j in range(cols) if i != j)

def vector_variable(letter, length):
    return sp.Matrix(sp.symarray(letter, length))

def evaluate_character(character,torus_element):
    # Evaluate a character at a particular torus element
    # Character needs to be in the form of a vector like [1,0,0]
    
    # torus_element should be a diagonal square matrix, and should match character length
    assert(is_diagonal(torus_element)) 
    rows, cols = sp.shape(torus_element)
    assert(rows == cols == len(character)) 
    
    return_value = 1;
    for i in range(len(character)):
        return_value = return_value * (torus_element[i,i]**character[i])
    return return_value

def is_zero_expr(expr):
    # return zero if expression is zero, regardless of matrix or scalar quantity
    return expr.equals(0) if not hasattr(expr, 'shape') else expr.equals(sp.zeros(*expr.shape))

def matrix_sub(expr, matrix_to_replace, matrix_to_substitute):
    return expr.subs(dict(zip(matrix_to_replace, matrix_to_substitute)))

def generate_character_list(character_length, upper_bound, padded_zeros):
    # Return a list of all possible integer vectors of length character_length
    #   with entries ranging from -upper_bound to +upper_bound
    # The last few digits are all zeros, so the number of entries that 
    #   can vary are just character_length-padded_zeros 
    padded_zeros = max(padded_zeros, 0) # needs to be at least zero
    return [np.array(c + (0,) * padded_zeros, dtype=int) 
            for c in itertools.product(range(-upper_bound, upper_bound + 1),
                                       repeat=character_length - padded_zeros)]

def reduce_character_list(vector_list, lattice_matrix):
    # take a list of numpy vectors, and return a sub-list
    # consisting of only vectors which are not pairwise equivalent
    # under quotienting by a lattice generated by the columns of lattice_matrix
    
    if len(lattice_matrix) == 0: return vector_list # If no lattice matrix, everything is distinct
    
    V = vector_list
    W_mat = sp.Matrix(lattice_matrix).transpose()   # Matrix whose rows span W
    Q = W_mat.nullspace()                           # Basis for the null space of W_mat
    
    def max_entry(v): return max(abs(x) for x in v)
    def support_size(v): return sum(1 for x in v if x != 0)
    def length_sq(v): return sum(x*x for x in v)
    def support_pattern(v): return tuple(1 if x != 0 else 0 for x in v)
    
    # Comparison key, higher is preferred
    def priority_key(v):
        return (
            -max_entry(v),        # smaller maximum entry preferred
            -support_size(v),     # fewer nonzeros is better
            -length_sq(v),        # shorter vector preferred
            support_pattern(v)    # earlier nonzeros preferred
        )
    
    # If nullspace is trivial, everything is equivalent, just return the best vector by priority key
    if not Q: return [max(V, key=priority_key)]
    
    # Matrix whose rows are a basis for the null space of W_mat
    Q_mat = sp.Matrix.vstack(*[q.T for q in Q]) 
    
    best = {}
    for v in V:
        key = tuple(Q_mat * sp.Matrix(v))
        if key not in best or priority_key(v) > priority_key(best[key]): best[key] = v
    return list(best.values())

def determine_roots(generic_torus_element,
                    generic_lie_algebra_element,
                    list_of_characters,
                    variables_to_solve_for,
                    time_updates = False):
    
    # Caculate roots and root spaces
    # return in a dictionary format, where keys are roots (as tuples)
    # and the value is the generic element of the root space
    root_space_dict = {}
    t = generic_torus_element
    x = sp.Matrix(generic_lie_algebra_element)
    LHS = sp.simplify(t*x*t**(-1))
    
    if time_updates:
        print("\nComputing roots...")
        n = len(list_of_characters)
        print("Testing " + str(n) + " candidate characters.")
        i = 0
        t0 = time.time()
    
    for alpha in list_of_characters:
        
        if time_updates:
            i = i + 1
            t1 = time.time()
            if i % 100 == 0:
                print("\tTesting candidate", i)
                print("\tRoots found so far:", len(root_space_dict))
                elapsed = t1-t0
                avg = elapsed/i
                remaining = (n-i)*avg
                print("\tTime elapsed:", int(elapsed), "seconds")
                print("\tAverage time per root:", round(avg,2), "seconds")
                print("\tEstimated time remaining:", int(remaining), "seconds")
            
        alpha_of_t = evaluate_character(alpha,t)
        if alpha_of_t != 1: # ignore cases where the character is trivial
            RHS = alpha_of_t*x
            my_equation = sp.simplify(LHS-RHS)
            solutions_list = sp.solve(my_equation,variables_to_solve_for,dict=True)
            assert(len(solutions_list) == 1)
            solutions_dict = solutions_list[0]
            if len(solutions_dict) > 0 :
                all_zero = True 
                for var in variables_to_solve_for:  # check that not all variables are zero
                    if not(var in solutions_dict.keys()) or solutions_dict[var] != 0:
                        all_zero = False
                        break
                if not(all_zero): # For nonzero characters with a solution, add as a root
                    generic_root_space_element = x
                    for var, value in solutions_dict.items():
                        generic_root_space_element = generic_root_space_element.subs(var,value)
                    if not generic_root_space_element.is_zero_matrix:
                        root_space_dict[tuple(alpha)] = sp.simplify(generic_root_space_element)
    return root_space_dict