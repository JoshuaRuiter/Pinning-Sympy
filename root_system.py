# This is a custom class to model root systems of Lie algebras.
# There is a built-in class implemented by Sympy, but it lacks some functionality.

# Note that these root systems are not assumed to be reduced, i.e. they do not necessarily
# satisfy the assumption that the only multiple of a root in the root system are +1 and -1.
# Dropping this axiom leads to some "non-reduced root systems," but all such root systems are
# of type BC, which is essentially the union of the type B and type C root systems 
# (given a certain realization/embedding of these root systems).
# In particular, type BC includes some roots where twice the root is another root
# (so for those longer roots, half that root is a root).

import numpy as np
import sympy as sp
from utility_roots import connected_components, directed_dynkin_graphs, visualize_graph
from utility_general import in_integer_column_span, ints_near_zero #, quotient_norm
from bidict import bidict

class root_system:
    
    # A model of a root system object
    # root_list stores a list of numpy arrays (all of equal length), representing roots
    # lattice_matrix is a matrix whose columns are equal in length to the roots
    
    # Let L be the lattice generated by the columns of equivalence_matrix.
    # Root vectors are viewed as representatives of classes in the quotient lattice Z^n/L
    # i.e. two vectors are the same if their difference is in L.
    
    def __init__(self, root_list, lattice_matrix = None, full_init =  True):
    
        # check that all roots are tuples
        for r in root_list:
            assert type(r) == tuple, "Root system can only be constructed using tuples"
    
        self.root_list = root_list
        
        # check that all roots are vectors have same length/dimension
        first_vec_length = len(self.root_list[0])
        for alpha in self.root_list: 
            assert len(alpha) == first_vec_length, "Root system can't have vectors of different lengths"
        self.vector_length = first_vec_length
        
        if lattice_matrix is None:
            # make the lattice_matrix a single column of zeros if there isn't one
            self.lattice_matrix = sp.zeros((self.vector_length, 1))
        else:
            self.lattice_matrix = lattice_matrix
        
        # check that lattice matrix has a number of rows equal to the length of the roots
        assert self.vector_length ==  self.lattice_matrix.shape[0], "Lattice matrix has wrong number of rows"
        
        # Construct a basis for the orthogonal complement of the lattice L generated by lattice_matrix,
        # then construct a basis for the quotient space Z^n/L
        # Find coordinates for each root in that quotient basis,
        # then construct a bidirectional dictionary object in which keys are original roots,
        # and values are quotient basis coordinates.
        # The bidirectional dictionary allows for quick lookup in either direction.
        complement_basis = sp.Matrix(self.lattice_matrix).transpose().nullspace()
        self.quotient_basis = sp.Matrix.hstack(*complement_basis)
        self.root_bidict = bidict()
        for r in root_list:
            q = self.project_to_quotient(r)
            self.root_bidict[r] = q
            
        # print("\n\nComplement basis:",complement_basis)
        # print("Quotient basis:",self.quotient_basis)
        # print("Root bidictionary:",self.root_bidict)
        # print()

        # Determine the irreducible components
        component_root_lists = root_system.determine_irreducible_components(self.root_list)
        self.is_irreducible = (len(component_root_lists) == 1)
        
        if not self.is_irreducible:
            self.components = [root_system(c, self.lattice_matrix, full_init = True) for c in component_root_lists]
        
        if full_init:
            if self.is_irreducible:
                self.determine_properties()
            else:
                self.name_string = ""
                for c in self.components:
                    c.determine_properties()
                    self.name_string = self.name_string + "_x_" + c.name_string
                self.name_string = self.name_string[3:]
    
    def determine_properties(self):
        # Determine and populate various internal variables of the root system, including:
        #   -sorted list of root lengths
        #   -simply laced or not
        #   -reduced vs nonreduced
        #   -choose a set of positive roots
        #   -choose a set of simple roots
        #   -compute the Cartan matrix with a choice of simple roots
        #   -compute the underlying graph of the Dynkin diagram from the Cartan matrix
        #   -connectedness
        #   -determine the Dynkin type from various other info above
        
        # Key assumption: the root system is irreducible
        # Some of these properties and computations still apply to reducible root systems,
        # but particularly the Dynkin type classification only makes sense for
        # irreducible root systems.
        assert(self.is_irreducible)
        
        # Make an ordered list of root lengths,
        # then determine if all roots are the same length, 
        # i.e. whether the root system is simply laced
        self.root_lengths = sorted({np.dot(r, r) for r in self.root_list})
        self.is_simply_laced = (len(set(self.root_lengths)) == 1)
        
        # Check for non-reduced-ness,
        # i.e. if there are any pairs of roots that
        # are proportional in a ratio other than +/-1
        self.is_reduced = True
        for i, alpha in enumerate(self.root_list):
            for beta in self.root_list[i+1:]:
                proportional, ratio = self.is_proportional(alpha, beta, with_ratio = True)
                if proportional and ratio not in (1,-1):
                    self.is_reduced = False
                    self.dynkin_type = 'BC'
                    break
            if not self.is_reduced:
                break
        
        # Make choices of positive and simple roots
        # Note that there are many equally valid choices of positive roots,
        # and this is only one such valid choice.
        # The implementation here is non-deterministic. 
        # Specifically, it chooses a random vector and then assigns all 
        # roots on one side of the associated perpendicular hyperplane
        # to be positive. Because of this randomness, a seed argument
        # is included so that you can get a consistent (though still arbitrary)
        # choice of positive roots.
        self.positive_roots_bidict = root_system.choose_positive_roots(self.root_bidict,max_tries=100,seed=0)
        self.simple_roots_bidict = root_system.choose_simple_roots(self.positive_roots_bidict)
        
        # Check that the number of simple roots is the same as the
        # rank of the matrix spanned by the list of all roots
        # and the same as the rank of the matrix spanned by the roots in the quotient basis
        matrix_of_roots = sp.Matrix(list(self.root_bidict.keys()))
        matrix_of_quotient_roots = sp.Matrix(list(self.root_bidict.values()))
        assert len(self.simple_roots_bidict) == matrix_of_roots.rank() == matrix_of_quotient_roots.rank(), \
            "Rank computations mismatch"
        self.rank = len(self.simple_roots_bidict)
        
        # Build the Cartan matrix from the choice of simple roots
        self.cartan_matrix = root_system.build_cartan_matrix(self.simple_roots_bidict)
        
        # Build the (directed, weighted) Dynkin diagram/graph
        self.dynkin_graph = root_system.build_directed_dynkin_graph(self.simple_roots_bidict)
        
        # Double check irreducibility
        # Irreducibility is equivalent to the Dynkin graph being connected.
        assert(len(connected_components(self.dynkin_graph)) == 1)
        
        # Determine the Dynkin type of each component using the Dynkin diagram
        # If the root system is non-reduced, the Dynkin type must be 'BC',
        # and this should already have been set above.
        if self.is_reduced:
            self.dynkin_type, r = root_system.determine_dynkin_type(self.dynkin_graph)
            assert self.rank == r, "Rank computations mismatch"
        else:
            assert self.dynkin_type == 'BC', "Non-reduced root system must be type BC"
        
        self.name_string = self.dynkin_type + str(self.rank)
    
    def project_to_quotient(self, vector):
        return tuple((self.quotient_basis).solve_least_squares(sp.Matrix(vector)))
    
    def quotient_norm(self, vector):
        projection = np.array(self.project_to_quotient(vector))
        return np.dot(projection, projection)
    
    @staticmethod
    def determine_irreducible_components(roots):
        n = len(roots)
        visited = [False]*n
        components = []
        for i in range(n):
            if visited[i]:
                continue
            stack = [i]
            comp_indices = []
            while stack:
                k = stack.pop()
                if visited[k]:
                    continue
                visited[k] = True
                comp_indices.append(k)
                for j in range(n):
                    if not visited[j] and np.dot(roots[k], roots[j]) != 0:
                        stack.append(j)
            components.append([roots[k] for k in comp_indices])
        return components
    
    @staticmethod
    def choose_positive_roots(root_bidict, max_tries = 100, seed = 0):
        
        # Procedure: choose a hyperplane not containing any of the roots
        # then choose one of the sides of that hyperplane.
        # All roots on that side of the hyperplane are positive.
        vector_length = len(next(iter(root_bidict.values())))
        
        # Use a numpy random generator object so that
        # results of choosing positive roots are consistent
        # between different runs of the code
        rng = np.random.default_rng(seed)
        
        for t in range(max_tries):
            random_vec = rng.random(vector_length) # Generate a random vector
            # Compute the dot product of that vector with every root
            dot_products = [np.dot(random_vec, r) for r in root_bidict.values()]
            if 0 in dot_products:
                # If the random vector is perpendicular to any roots, that causes a problem
                # This is very rare probabalistically, but it can theoretically happen
                # If it does happen, just choose a new random vector
                continue
            else:
                # Choose the positive roots to be roots with positive dot product with the random vector
                # positive_roots = [r for (r, val) in zip(root_list, dot_products) if val > 0]
                positive_roots = bidict({k: r for (k, r), val in zip(root_bidict.items(), dot_products) if val > 0})
                return positive_roots
        raise RuntimeError("Failed to find a vector not proportional to a root.")
        
    def choose_simple_roots(positive_roots_bidict):
        simple_roots = bidict()
        for key_alpha, alpha in positive_roots_bidict.items():
            is_simple = True
            for key_beta, beta in positive_roots_bidict.items():
                if alpha == beta or all(x == 0 for x in beta):
                    continue
                gamma = tuple(np.array(alpha) - np.array(beta))
                # Check if gamma is in the positive roots
                if gamma in positive_roots_bidict.values():
                    is_simple = False
                    break
            if is_simple:
                simple_roots[key_alpha] = alpha
        return simple_roots
    
    @staticmethod
    def build_cartan_matrix(simple_roots_bidict):
        simple_roots = list(simple_roots_bidict.values())
        rank = len(simple_roots)
        A = np.zeros((rank, rank), dtype=int)
        for i, alpha in enumerate(simple_roots):
            for j, beta in enumerate(simple_roots):
                # Compute dot product manually for tuples
                dot_alpha_beta = sum(a * b for a, b in zip(alpha, beta))
                dot_beta_beta = sum(b * b for b in beta)
                A[i, j] = int(round(2 * dot_alpha_beta / dot_beta_beta))
        return A

    @staticmethod
    def build_directed_dynkin_graph(simple_roots_bidict):
        cartan_matrix = root_system.build_cartan_matrix(simple_roots_bidict)
        simple_roots = list(simple_roots_bidict.values())
        assert len(simple_roots) == cartan_matrix.shape[0], \
            "Cartan matrix dimensions do not match number of simple roots"
        rank = len(simple_roots)
        graph = {i: {} for i in range(rank)}
        
        for i, alpha_i in enumerate(simple_roots):
            len_i = sum(x*x for x in alpha_i) # squared length, without converting to numpy
            for j, alpha_j in enumerate(simple_roots):
                if i == j:
                    continue
                len_j = sum(x*x for x in alpha_j)
                a_ij = cartan_matrix[i, j]
                a_ji = cartan_matrix[j, i]
                if a_ij != 0:
                    mult = max(abs(a_ij), abs(a_ji))
                    if len_i > len_j:
                        # i -> j
                        graph[i][j] = mult
                        graph[j][i] = 1
                    elif len_i < len_j:
                        # j -> i
                        graph[i][j] = 1
                        graph[j][i] = mult
                    else:
                        # equal length, symmetric single edge
                        graph[i][j] = 1
                        graph[j][i] = 1
        return graph

    @staticmethod
    def determine_dynkin_type(dynkin_graph):
        # Determine the dynkin type of an irreducible, reduced root system from its
        # (weighted, directed) Dynkin graph
        
        # If the root system is not reduced, then this method will not help.
        # In that case, you can't actually tell apart types B and BC from the Dynkin graph anyway,
        # so it would be impossible to classify.
        
        my_rank = len(dynkin_graph)
        
        if my_rank == 1: 
            # This needs to be checked before computing other properties,
            # because other calculations fail to work in this case
            return ('A', 1)
    
        # Compute some useful characteristics of the graph
        degree_dict = {v: len(dynkin_graph[v]) for v in dynkin_graph}
        degrees = list(degree_dict.values())
        edge_multiplicities = sorted(mult for v in dynkin_graph for mult in dynkin_graph[v].values())
        is_simply_laced = (max(edge_multiplicities, default = -1) == 1)
        nodes_with_multiple_leaf_neighbors = [
            v for v in dynkin_graph
            if sum(1 for u in dynkin_graph[v] if len(dynkin_graph[u]) == 1) > 1
        ]
        leaf_nodes = [v for v in dynkin_graph if len(dynkin_graph[v]) == 1]
        single_edge_leaf_nodes = []
        
        for v in leaf_nodes:
            simple_edges = True
            outgoing_edges = sum(dynkin_graph[v].values())
            if outgoing_edges > 1:
                simple_edges = False
                break
            for u in dynkin_graph:
                if v in dynkin_graph[u] and dynkin_graph[u][v] > 1:
                    simple_edges = False
                    break
            if simple_edges:
                single_edge_leaf_nodes.append(v)
        num_single_edge_leaf_nodes = len(single_edge_leaf_nodes)
        double_edge_to_leaf = False
        for v in leaf_nodes:
            for u in dynkin_graph:
                if v in dynkin_graph[u] and dynkin_graph[u][v] > 1:
                    double_edge_to_leaf = True
    
        # Sort into Dynkin type based on characteristics
        if is_simply_laced:
            if 3 not in degrees: # no forks, so type A
                my_type = 'A'
            elif len(nodes_with_multiple_leaf_neighbors) >= 1:
                # D has a node with two leaf neighbors, E does not
                my_type = 'D'
                assert(my_rank >= 4)
            else:
                my_type = 'E'
                assert(my_rank in (6,7,8))
        else: # non-simply-laced case
            if 3 in edge_multiplicities:
                my_type = 'G'
                assert(my_rank == 2)
            elif num_single_edge_leaf_nodes == 2:
                my_type = 'F'
                assert(my_rank == 4)
            else:
                if double_edge_to_leaf:
                    my_type = 'B'
                    assert(my_rank >= 2)
                else:
                    my_type = 'C'
                    assert(my_rank >= 3)
    
        return my_type, my_rank

    def is_root(self, vector_to_test):
        # Input: a ROW vector of the same length as original vectors used to build the root system
        # What happens: the input vector is converted to projected quotient coordinates,
        #               then compared with the list of projected canonical representatives
        
        # print("\n\nTesting if something is a root")
        # print("Testing the vector:",vector_to_test)
        
        assert type(vector_to_test) == tuple, "is_root expects tuples"
        projection = self.project_to_quotient(vector_to_test)
        return tuple(projection) in self.root_bidict.values()
        
    def is_multipliable_root(self, vector_to_test):
        # Return true if vector_to_test is a root and
        # twice that is another root
        double = tuple(2*np.array(vector_to_test))
        return (self.is_root(vector_to_test) and self.is_root(double))
    
    def reflect_root(self, alpha, beta):
        v = np.array(self.root_bidict[alpha])
        w = np.array(self.root_bidict[beta])
        reflection = v - 2 * np.dot(v, w) / np.dot(w, w) * w
        
        print("\n\nComplete bidictionary of roots:")
        for key, value in self.root_bidict.items():
            print("Key=",key)
            print("Value=",value)
            print()
        
        print("\n\nReflecting a root")
        print("alpha=",alpha)
        print("beta=",beta)
        print("alpha in quotient coords=",v)
        print("beta in quotient coords=",w)
        print("reflection (in quotient coords)",reflection)        
        
        return self.root_bidict.inverse[tuple(reflection)]
    
    def is_proportional(self, alpha, beta, with_ratio = False):
        # Return true if alpha and beta are proportional roots
        # In most root systems, this only happens if alpha = beta or alpha = -beta,
        # but in the type BC root system it is possible to have alpha = 2*beta
        v = self.root_bidict[alpha]
        w = self.root_bidict[beta]
        if any((v[i] == 0) != (w[i] == 0) for i in range(len(v))): 
            return (False, None) if with_ratio else False
        ratios = [v[i] / w[i] for i in range(len(v)) if w[i] != 0]
        if all(x == 0 for x in v) and all(x == 0 for x in w):
            return (True, 0) if with_ratio else True
        elif all(r == ratios[0] for r in ratios):
            return (True, ratios[0]) if with_ratio else True
        else:
            return (False, None) if with_ratio else False
    
    def integer_linear_combos(self,alpha,beta):
        # Return a list of all positive integer linear combinations
        # of two roots alpha and beta within a list of roots
        assert self.is_root(alpha) and self.is_root(beta), "Can't compute integer linear combos with non-roots"
        
        # The output is a dictionary, where keys are tuples (i,j)
        # and values are roots of the form i*alpha+j*beta
        combos = {}
        my_sum = tuple(a + b for a, b in zip(alpha,beta))
        if not(self.is_root(my_sum)):
            # If alpha+beta is not a root, there are no integer linear combos
            # and we return an empty list
            return combos
        else:
            combos[(1,1)] = my_sum
        
        # Run a loop where each iteration, we try adding alpha and beta
        # to each existing combo
        while True:
            new_combos = self.increment_combos(alpha,beta,combos)
            if len(combos) == len(new_combos):
                break;
            combos = new_combos
        return combos
    
    def increment_combos(self,alpha,beta,old_combos):
        new_combos = old_combos.copy() # A shallow copy
        for key in old_combos:
            i = key[0]
            j = key[1]
            old_root = old_combos[key]
            sum_with_alpha = tuple(a+b for a,b in zip(alpha, old_root))
            sum_with_beta = tuple(a+b for a,b in zip(beta, old_root))
            if self.is_root(sum_with_alpha):
                new_combos[(i+1,j)] = sum_with_alpha
            if self.is_root(sum_with_beta):
                new_combos[(i,j+1)] = sum_with_beta
        return new_combos
    
    def verify_root_system_axioms(self, display = True):
        if display: print('\nRunning tests to verify root system axioms for the ' 
                          + self.name_string + ' root system.')
        
        if display: print('\tChecking that zero is not a root...',end='')
        #zero_vector = np.zeros((1,self.vector_length),dtype=int)
        zero_vector = (0,) * self.vector_length
        assert not(self.is_root(zero_vector)), "Zero vector should not be a root"
        if display: print('passed.')
        
        if display: print('\tChecking that the negative of a root is a root...',end='')
        for alpha in self.root_list:
            negative_alpha = tuple(-np.array(alpha))
            assert self.is_root(negative_alpha), "Negative of root is not a root"
        if display: print('passed.')
        
        if display: print('\tChecking that a reflection of a root is another root...',end='')
        for alpha in self.root_list:
            for beta in self.root_list:
                assert self.is_root(self.reflect_root(alpha,beta)), "Reflection of a root is not a root but should be"
        if display: print('passed.')
        
        if display: print('\tChecking that the angle bracket of two roots is an integer...',end='')
        for alpha in self.root_list:
            for beta in self.root_list:
                v = np.array(self.root_bidict[alpha])
                w = np.array(self.root_bidict[beta])
                angle_bracket = 2*np.dot(v,w)/np.dot(v,v)
                assert angle_bracket == int(angle_bracket), "Angle bracket of roots should be an integer"
        if display: print('passed.')
        
        if display: print('\tChecking that ratios between proportional roots are +/-1, +/-2, or +/-0.5...',end='')
        for alpha in self.root_list:
            for beta in self.root_list:
                proportional, ratio = self.is_proportional(alpha,beta,with_ratio=True)
                if proportional: assert ratio in (1.0,-1.0,2.0,-2.0,0.5,-0.5), "Invalid ratio between roots"
        if display: print('passed.')
        if display: print('Root system axiom checks completed.')
    
    @staticmethod
    def test_dynkin_classifier():
        # Run a battery of tests to verify that the dynkin type classifier works
        print("Testing Dynkin type classifier on a pre-populated list of irreducible reduced root systems...")
        for name in directed_dynkin_graphs:
            print("\nName:",name)
            true_type = name[0]
            true_rank = int(name[-1])
            print("\tTrue type:",true_type)
            print("\tTrue rank:",true_rank)
            
            graph = directed_dynkin_graphs[name]
            print("\tGraph visualization:", visualize_graph(graph))
            print("\tGraph as dictionary:",graph)
            
            calculated_type, calculated_rank = root_system.determine_dynkin_type(graph)
            print("\tDetermined type:",calculated_type)
            print("\tDetermined rank:",calculated_rank)
            assert(true_type == calculated_type)
            assert(true_rank == calculated_rank)
            
        print("\nAll tests passed.")